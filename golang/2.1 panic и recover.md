`panic` и `recover` — это встроенный механизм Go для обработки  **критических ошибок**, при которых продолжение выполнения невозможно. Эта связка похожа на исключения.

---
# panic
- Начинает размотку стека в текущей горутине.  
- Выполняет все отложенные [2.2 defer](2.2%20defer.md) функции на пути размотки.  
- Если `panic` не перехвачен, программа завершается с трассировкой стека.  
- Источники:
  - Явный вызов `panic(reason)`
  - Ошибки рантайма (nil-pointer dereference, выход за границы массива и т.д.)
## Типичные случаи использования
- Нарушение инвариантов  
- Состояния, которые "никогда не должны случиться"  
- Критические ошибки инициализации  
## Пример
```go
func mustPositive(n int) {
    if n < 0 {
        panic("number must be positive")
    }
}
```
# recover
- Работает **только внутри отложенной функции**.
- Останавливает размотку стека и восстанавливает обычное выполнение.
- Если `recover()` не вызван во время размотки, программа завершится. 
## Пример

```go
func safe() {     
	defer func() {         
		if r := recover(); r != nil {             
			fmt.Println("Recovered:", r)         
		}     
	}()     
	panic("boom") 
}
```
# recover in side-function
Recover отработает только если он вызван в той же функции, что и panic, внутри defer. Компилятор запрещает [инлайнинг](<function.md#panic и recover recover prevents inline>), перехвата не происходит.
```go
package main

import (
	"fmt"
)

func RecoverAndRun() { // cannotInlineFunction (call to recover)
	r := recover(); r != nil {
		fmt.Println("return from panic")
	}
}

func main() {
	defer func() {
		fmt.Println("End of work")
		RecoverAndRun() // BAD CODE!!!!!!
	}
	
	panic("Panic")
}

/*
Вывод программы:

End of work
Panic
*/
```
# Перехват завершения работы
## runtime.Goexit()
- Завершение **текущей** горутины без паники
- Выполнение всех отложенных функций (defer)
- Влияние на родительскую горутину и scheduler
## os.Exit(code)
- Немедленное завершение процесса
- Не выполняет defer, не запускает сборку мусора, не даёт шанс runtime завершить работу корректно
## Сравнение механизмов завершения
- panic: ошибка + раскрутка стека
- recover: перехват panic
- Goexit: мягкое завершение горутины
- os.Exit: жёсткое завершение процесса
# Когда нельзя перехватить панику
1. Переполнение стека
2. Нехватка памяти (OOM)
# Частые шаблоны использования panic/recover

## 1. Безопасный запуск горутины
Защищает процесс от падения из-за паники внутри горутины.

```go
go func() {     
	defer func() {         
		if r := recover(); r != nil {             
			log.Printf("goroutine panic: %v", r)         
		}     
	}()     
	doWork() 
}()
```
## 2. Проброс паники с логгированием
Используется библиотеками для логирования, но с сохранением критического поведения.

```go
defer func() {     
	if r := recover(); r != nil {         
		log.Println("critical:", r)         
		panic(r)     
	} 
}()
```
## 3. Преобразование panic в error
Полезно при обертке кода, который не должен “ронять” всю программу.

```go
func runSafe(fn func()) (err error) {     
	defer func() {         
		if r := recover(); r != nil {             
			err = fmt.Errorf("panic: %v", r)         
		}    
	}()     
	fn()     
	return nil 
}
```

# Краткое резюме для интервью

- `panic` разматывает стек, `recover` может остановить этот процесс.
- `recover` работает **только в defer**.
- Есть случаи, когда нельзя выполнить recover (OOM, stack overflow)
- Можно использовать для сброса состояния горутины (actors model)
- Используется для исключительных и неустранимых ситуаций.
- Идиоматичный Go предпочитает явные `error` для нормальной логики.