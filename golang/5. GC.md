# До 1.25, Concurrent mark & sweep (Tracing)
- Трехцветный ([трехцветный поиск цикла в графе](https://neerc.ifmo.ru/wiki/index.php?title=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B0_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83_%D0%B4%D0%BB%D1%8F_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0_%D1%86%D0%B8%D0%BA%D0%BB%D0%B0))
	1. Черный - объект живой, не нужно очищать
	2. Серый - объект подлежит сканированию на другие ссылки в куче
	3. Белый - объект не используется, подлежит очистке
- Нужен для освобождения памяти **в куче** от объектов, на которые нет валидных (сильных) ссылок
- [Source code](https://cs.opensource.google/go/go/+/master:src/runtime/mgc.go;l=91)
## Когда запускается
- Когда память заполняется до определенного значения (MEMLIMIT, GOGC)
- Раз в две минуты (запускает sysmon)
- Вручную: `runtime.GC()`
- Можно полностью отключить: `GOGC=off`
## GOGC & MEMLIMIT
### GOGC
- Дефолтное значени - 100
- Увеличение в 2 раза - увеличивает потребление памяти в 2 раза, но снижает расходы CPU ~2раза
- Влияет на частоту запуска GC
- Формула расчета : 
	- Живые объекты - оставшиеся после пред. цикла GC
	- Корневые объекты - в стеках горутин / глобальных перменных
```
Размер памяти в куче,   Размер    (Размер живых + Размер корневых) x GOGC
при котором стартует =   живых  + ---------------------------------------
след. цикл GC           объектов                     100

	  
	          (8mb + 2mb) x 100
13 mb = 8mb + -----------------
                     100
```
### MEMLIMIT
- Максимальный размер кучи, которые может быть использован приложением
 - При достижении - запускается GC
 - Даже если отключить GC - при достижении MEMLIMIT он включится
 - Можно задавать для приложений, которые крутятся в кубере и мы знаем сколько памяти выделено под каждый pod. Других приложений в этом поде не должно быть.
## Потребление
- Забирает 25% ресурсов CPU себе
- Если начинается очень большая аллокация, то GC может привлечь к разметке другие горутины (mark assist). В первую очередь привлекаются те, которые больше всех аллоцируют
## Stop The World
[Asynchronous preemptive](concurrency/GMP%20model.md##Asynchronous%20preemptive) выполнение также играет ключевую роль в сборке мусора:
1. Runtime выставляет флаг `preempt` для всех горутин.
2. Горутины приостанавливают выполнение в безопасных точках.
3. Сборщик мусора безопасно сканирует память, освобождает неиспользуемые объекты и возобновляет выполнение всех горутин после завершения своей работы.
## Алгоритм
1. **Sweep Termination**: 
	1. Stop The World (безопасное замораживание всех горутин)
	2. очищаются все необработанные спаны (группа страниц из кучи с аллоцированными объектами). Это происходит только при внеочередном вызове GС вручную или достижении лимита памяти (MEMLIMIT). В ином случае, при запуске GС ожидает что все страницы (объекты) будут очищены.
2. **Mark**: 
	1. Активируется барьер на запись 
	2. Поднимаются mark assist 
	3. Инциализируется очередь для объектов, которые нужно исследовать
	4. Start The World - все горутины начинают свою работу 
	5. Начинается конкурентная разметка: 
		0. Все объекты в куче помечаются белым цветом. 
		1. GC сканирует все [Стек горутины](memory%20model/Стек%20горутины.md) и глобальные переменные на наличие ссылок на объекты в куче. Находит и добавляет в очередь на сканирование, помечает все добавленные объекты серыми.
		2. В цикле:
			1. Достаем следующий объект из очереди
			2. Сканируем на наличие ссылок на другие объекты
			3. Если нашли - добавляем новые объекты в конец очереди, помечаем серым
			4. Помечаем исследованный объект черным
		3. Барьер на запись помечает новые объекты (которые аллоцируются во время разметки другими горутинами) сразу черным.   
		3. В конце разметки, остаются только белые и черные объекты. Черные никогда не ссылаются на белые!	
3. **Mark termination**: 
	1. Stop the world
	2. отключаются mark assist, воркеры разметки.  
	3. все белые спаны помечены как «требует очистки».
4. **Sweep**: 
	1. снимается барьер на запись 
	2. Start The World.
	3. Фаза очистки происходит одновременно с обычным выполнением программы. Куча лениво очищается от спана к спану (по требованию горутины новой памяти) и одновременно в фоновой горутине (оптимизация).

По достижению условия запуска GC, все начинается с 1го пункта.
```
                                  QUEUE                   
                                ┌────────┐ ┌────────────┐
                                │        │ │ - - WHITE  │
   &obj1/g◄─────────────────────┼─&obj1  │ │ + - GREY   │
      │                         │        │ │ ~ - BLACK  │
      ▼                         │ &obj5  │ └────────────┘
   &obj3/w                      │        │               
                                │ &obj8  │               
                                │        │               
                                └────────┘               
   HEAP                                                  
 ┌───────────────────────────────────────┐               
 │┌+++++++┐ ┌───────┐ ┌───────┐ ┌───────┐│               
 │+       + │       │ │       │ │       ││               
 │+ obj1  + │ obj2  │ │ obj3  │ │ obj4  ││               
 │+       + │       │ │       │ │       ││               
 │└+++++++┘ └───────┘ └───────┘ └───────┘│               
 │┌+++++++┐ ┌───────┐ ┌───────┐ ┌+++++++┐│               
 │+       + │       │ │       │ +       +│               
 │+ obj5  + │ obj6  │ │ obj7  │ + obj8  +│               
 │+       + │       │ │       │ +       +│               
 │└+++++++┘ └───────┘ └───────┘ └+++++++┘│               
 │┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐│               
 ││       │ │       │ │       │ │       ││               
 ││ obj9  │ │ obj10 │ │ obj11 │ │ obj12 ││               
 ││       │ │       │ │       │ │       ││               
 │└───────┘ └───────┘ └───────┘ └───────┘│               
 └───────────────────────────────────────┘               
                                         
                                 QUEUE                   
                                ┌────────┐                           
   &obj1/b(alive)               │ &obj5  │               
      │                         │        │               
      ▼                         │ &obj8  │               
   &obj3/g(inspect)             │        │               
                                │ &obj3  │                     
                                └────────┘               
   HEAP                                                  
 ┌───────────────────────────────────────┐               
 │┌~~~~~~~┐ ┌───────┐ ┌+++++++┐ ┌───────┐│               
 │~       ~ │       │ +       + │       ││               
 │~ obj1  ~ │ obj2  │ + obj3  + │ obj4  ││               
 │~       ~ │       │ +       + │       ││               
 │└~~~~~~~┘ └───────┘ └+++++++┘ └───────┘│               
 │┌+++++++┐ ┌───────┐ ┌───────┐ ┌+++++++┐│               
 │+       + │       │ │       │ +       +│               
 │+ obj5  + │ obj6  │ │ obj7  │ + obj8  +│               
 │+       + │       │ │       │ +       +│               
 │└+++++++┘ └───────┘ └───────┘ └+++++++┘│               
 │┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐│               
 ││       │ │       │ │       │ │       ││               
 ││ obj9  │ │ obj10 │ │ obj11 │ │ obj12 ││               
 ││       │ │       │ │       │ │       ││               
 │└───────┘ └───────┘ └───────┘ └───────┘│               
 └───────────────────────────────────────┘               
                                        
                                QUEUE                    
                               ┌────────┐                             
   &obj1/b      &obj5/b◄───────┼─&obj5  │                
      │           │   │        │        │                
      ▼           ▼   ▼        │ &obj8  │                
   &obj3/g  &obj10/g  &obj12/g │ &obj3  │                
                               │ &obj10 │                
                               │ &obj12 │                
                               └────────┘                
  HEAP                                                   
┌───────────────────────────────────────┐                
│┌~~~~~~~┐ ┌───────┐ ┌+++++++┐ ┌───────┐│                
│~       ~ │       │ +       + │       ││                
│~ obj1  ~ │ obj2  │ + obj3  + │ obj4  ││                
│~       ~ │       │ +       + │       ││                
│└~~~~~~~┘ └───────┘ └+++++++┘ └───────┘│                
│┌~~~~~~~┐ ┌───────┐ ┌───────┐ ┌+++++++┐│                
│~       ~ │       │ │       │ +       +│                
│~ obj5  ~ │ obj6  │ │ obj7  │ + obj8  +│                
│~       ~ │       │ │       │ +       +│                
│└~~~~~~~┘ └───────┘ └───────┘ └+++++++┘│                
│┌───────┐ ┌+++++++┐ ┌───────┐ ┌+++++++┐│                
││       │ +       + │       │ +       +│                
││ obj9  │ + obj10 + │ obj11 │ + obj12 +│                
││       │ +       + │       │ +       +│                
│└───────┘ └+++++++┘ └───────┘ └+++++++┘│                
└───────────────────────────────────────┘                 
```
## Сильные и слабые ссылки
Объект помечается неиспользуемым, если кол-во сильных ссылок на него равняется нулю, независимо от количества активных слабых ссылок.
## SetFinalizer
В пакете runtime определена функция `func SetFinalizer(obj any, finalizer any)`.
- Можно определить функцию для объекта. Она получает на вход указатель на объект, будет вызвана перед тем, как GC очистит этот объект.
- Объекты с финализатором требуют **КАК МИНИМУМ** 2 цикла GC, чтобы освободиться: вызов финализатора потом очистка.
- В райнайме, финализатор проверяет соответствие типа переданного объекта и тип в функции финализации.
- Вызов `runtime.SetFinalizer` не идемпотентен. Если вызвать 2 раза на один объект - будет паника `finalizer already set`.
- Нет гарантий, что при завершении программы будет вызван GC и финализаторы.
- Нет гарантий работы с [объектами, которые весят 0 байт](types/struct.md#Пустая%20структура).
```go
func NewData(name string) *Data {
	data := &Data{name:name}
	
	runtime.SetFinalizer(data, func(ptr *Data) {
		fmt.Println("finalizer: addr", unsafe.Pointer(ptr), "value is", ptr.name)
	})
}

func main() {
	data := NewData("__data__")
	_=data

	runtime.GC()
	time.Sleep(time.Second)
}
```
### Файлы
Внутри исходного кода Go, используются финализаторы для автоматического закрытия файлов.
```go
func newFile(fd uintptr, name string, kind newFileKind) *File {
	// ...
	runtime.SetFinalizer(f.file, (*file).close)
	return f
}
```
### C-go
Можно автоматически деаллоцировать память, которую выделили из C-go.
```go
type Cstr struct{
	cpointer *C.char
}

func AllocateAuto() *Cstr {
	result := &Ctr(C.allocate())
	runtime.SetFinalizer(result, func(c *Cstr) {
		C.free_allocated(c.cpointer)
		runtime.KeepAlive(c)
	})
}
```
### Структуры
Если повесить финализатор не на первое поле структуры - будет [паника](2.1%20panic%20и%20recover.md#panic):
```go
func main() {
	foo := &Foo{a:1, b: "hello"}
	runtime.SetFinalizer(&foo.b, func(ptr *string) {
		fmt.Println("finalizer: addr", unsafe.Pointer(ptr), "value is", *ptr)
	})
	runtime.GC() // panic: pointer not at begining of allocated block
	time.Sleep(time.Second)
}
```
### Утечки при циклических ссылках
Если установить финализатор на объект, который участвует в циклических ссылках, то GC никогда не очистит эту память и финализатор не будет вызван.
```go
package main

import (
	"fmt"
	"runtime"
	"time"
)

type Foo struct {
	bar *Bar
}

type Bar struct {
	foo *Foo
}

func main() {
	foo := &Foo{}
	bar := &Bar{}

	foo.bar = bar
	bar.foo = foo

	runtime.SetFinalizer(foo, func(ptr *Foo) {
		fmt.Println("finalizer called on addr", ptr, "value is", *ptr)
	})

	//runtime.SetFinalizer(bar, func(ptr *Bar) {
	//	fmt.Println("finalizer called on addr", ptr, "value is", *ptr)
	//})

	runtime.GC()
	time.Sleep(5 * time.Second)
}
```
### Resurrection
Во время вызова финализатора, можно присвоить адрес очищенного объекта глобальной пермененной и "воскресить" объект, он так же останется в куче:
```go
package main

import (
	"fmt"
	"runtime"
	"time"
	"unsafe"
)

var globalData *Data

type Data struct {
	name string
}

func NewData(name string) *Data {
	data := &Data{
		name: name,
	}

	fmt.Println("created", name)
	runtime.SetFinalizer(data, func(ptr *Data) {
		fmt.Println("finalizer: addr", unsafe.Pointer(ptr), "value is", ptr.name)
		globalData = ptr // resurrection
	})

	return data
}

func main() {
	data := NewData("data")
	_ = data

	runtime.GC()
	time.Sleep(time.Second)

	fmt.Println("resurrected: addr", unsafe.Pointer(globalData), "value: ", globalData.name)
}
```

## AddCleanup
`func AddCleanup[T, S any](ptr *T, cleanup func(S), arg S)`
Улучшенная версия финализаторов, решает некоторые их проблемы:
- Построена на [дженериках](9.%20Generics.md), статически проверяет типы параметров функции финализации
- Запрещает воскрешать объекты: ptr != arg
- Вызов идемпотентен - можно определить несколько для одного объекта
- Вызывается в отдельной горутине, что может замедлить другие клинапы (ДОРОЖЕ финализатора)
```go
package main

import (
	"fmt"
	"os"
	"runtime"
	"time"
)

type FileWrapper struct {
	file *os.File
}

func NewFileWrapper(path string) *FileWrapper {
	file, _ := os.OpenFile(path, os.O_RDONLY|os.O_CREATE, 0666)

	ptr := &FileWrapper{file: file}

	runtime.AddCleanup(ptr, func(f *os.File) { // replace with FileWrapper
		fmt.Println("Closing file:", f.Name())
		_ = f.Close()
	}, ptr.file)

	return ptr
}

func main() {
	obj := NewFileWrapper(os.DevNull)
	_ = obj
	obj = nil

	runtime.GC()
	time.Sleep(time.Second)

	fmt.Println("Object is collected by GC")
}
```
# После 1.25, Green Tea
TBD
https://github.com/golang/go/issues/73581
https://go.dev/blog/greenteagc

