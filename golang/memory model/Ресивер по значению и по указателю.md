В Go метод принадлежит **конкретному типу**, и этот тип может иметь два варианта:
1. **Значение** (например `myError`)
2. **Указатель** (например `*myError`)

Каждая версия имеет **свой собственный метод-сет** (набор методов), и именно метод-сет определяет, может ли тип удовлетворить интерфейсу.

Напомним, что тип [2. error](2.%20error.md) - это интерфейс с методом `Error() string`.
# Pointer receiver
Если ресивер является указателем, то [интерфейсу](interface.md) удовлетворяет **ТОЛЬКО** указатель на структуру.
```go
package main

type Interface interface {
	Do()
}

type Object1 struct{}
func (o *Object1) Do() {}

func main() {
	var i Interface

	i = &Object1{}   // OK, pointer receiver
	//i = Object1{}  // compile time error, because value

	_ = i
}
```

Это старый пример, но он показательный:
```go
func handle() error{
	return &myError{text: "error"}
	//return myError{text: "error"} //cannot use myError{…}: does not implement error (method Error has pointer receiver)
}

func (m *myError) Error() string{
	return m.text
}

func main() {
	e := handle()
	_ = e.Error()
}
```
# Value receiver
Если ресивер является значением, то интерфейсу удовлетворяет как значение, так и указатель. 
Это логично, так как при вызове метода, Go автоматически разыменует указатель от структуры, чтобы вызвать метод.
```go
package main

type Interface interface {
	Do()
}

type Object2 struct{}
func (o Object2) Do() {}

func main() {
	var i Interface

	i = Object2{}  // OK
	i = &Object2{} // OK

	_ = i
}
```
# Биндинг методов
**СМЕШИВАТЬ** типы ресивером **ПЛОХО**!!!! В таком случае неочевидно как работает код.
Тут мы биндим методы объекта (присваиваем функции переменным). 

Как мы видим, мы можем вызвать метод `(d *Data) Value2()` с ресивером-указателем для `data := Data{100}`, которая объявлена без указателя. 
Такое работает **ТОЛЬКО** со [СТАТИЧЕСКИМИ](<interface.md#Static%20and%20dynamic%20type>) [типами](<struct.md>).

_Go’s compiler is allowed to **implicitly take the address** of a value of type `T` in order to call a pointer-receiver method `(*T).M`, but only when the value is addressable_.

В случае, когда мы биндим методы от Data, её значения захватываются(копируются) в том виде, в каком они были в момент захвата. Но для &Data мы захватываем указатель и при вызове его разыменовываем, получая актуальные данные:
```go
package main

import "fmt"

type Data struct {
	value int
}

func (d Data) Value1() int {
	return d.value // вернули скопированное значение
}

func (d *Data) Value2() int {
	return d.value // разыменовали указатель и взяли значение
}

func main() {
	data := Data{100}
	pointer := &data

	v1ByData := data.Value1   // захватили значение data с значением 100
	v1ByPtr := pointer.Value1 // разименовали и тоже захватили data с 100

	v2ByData := data.Value2   // компилятор сам взял адрес и передал в метод
	v2ByPtr := pointer.Value2 // передаем указатель на data с актуальными данными

	data.value = 200

	fmt.Println("value1ByData:", v1ByData())
	fmt.Println("value1ByPointer:", v1ByPtr())
	fmt.Println("value2ByData:", v2ByData())
	fmt.Println("v2ByPtr:", v2ByPtr())
}
```
# Best practice 
Ресивер должен быть **указателем** если:
- метод должен изменять получателя
- в получателе есть поле, которое нельзя копировать (из пакета `sync`)
- ресивер слишком большой
- функция возвращает интерфейс (таком случае не важно какой ресивер, так как будет пересечение )

Ресивер должен быть **значением**, если:
- нужно обеспечить неизменность ресивера
- ресивер это [примитивный тип](1.%20Data%20types.md) (они копируются и так)
- изменяемые поля не являются частью ресивера напрямую, а находятся внутри другой структуры
```go
type account struct {
	balance int
}

type client struct {
	account *account //Указатель скопируется и так, нет смысла делать (c *client)
}
```