Анонимные функции (lambda/closure) захватываю переменные по указателю. Т.е. если мы объявили переменную в рамках функции, и потом обращаемся к ней внутри `func()`, то мы управляем не копией, а тем самым объектом. 
Это позволяет передавать [chan](concurrency/chan.md), [sync.Waitgroup](sync.Waitgroup.md) в горутины очень просто.

```go
func (g *defaultWorkerGroup[Task]) startProducers(chanLen int) <-chan Task {
	output := make(chan Task, chanLen)
	go func() {
		defer close(output)
		for _, p := range g.producers {
			c := p.start(chanLen)
			for val := range c {
				output <- val
			}
		}
	}()
	return output
}
```

По стандарту языка, замыкания захватывают переменные по указателю. Так что, wg из скоупа функции main будет захвачена анонимной горутиной по указателю. В то же время, переменная цикла i тоже будет захвачена по указателю. 
До go 1.22, горутины напечатают последнее число цикла(нужно указать в ENV: GOEXPERIMENT=loopvar, чтобы пофиксить). В Go 1.22 это поведение исправили. 

```go
func main() {
	wg := sync.WaitGroup{}

	wg.Add(5)
	for  i := 0; i < 5; i++{
		go func() {
			defer wg.Done()
			fmt.Println(i)
		}()
	}

	wg.Wait()
}
```