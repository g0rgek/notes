# Общее объяснение
Важно понимать, что у программы есть несколько сегментов памяти:
- stack
- heap
- bss (неинициализированные данные)
- data (инциализированные данные)
- text (хранит текст программы и константы)
```
                +------------------------------+ | Grows
                |            Stack             | | Back 
                +------------------------------+ | (Down)
				|                              | |
			    |          free space          | V
                +~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
				|          PROTECTED AREA      |
				+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
                |                              | ^
                |          free space          | | Grows
                +------------------------------+ | Straight
                |             Heap             | | (Up)
                +------------------------------+ 
                |   Uninitialized Data (.bss)  |
                +------------------------------+
                |   Initialized Data (.data)   |
                +------------------------------+
                |      Code Segment (.text)    |
                +------------------------------+


  0x1016d    0x1016e                                  0x10193   0x10194
  +-------+  +-------+ +---+ +----------------+ +~~~+ +~~~~~~~+ +~~~~~~~+
  | a = 1 |  | b = 2 | |...| | PROTECTED AREA | |...| | d = 4 | | b = 3 |
  +-------+  +-------+ +---+ +----------------+ +~~~+ +~~~~~~~+ +~~~~~~~+ 
  ------>Heap                                              <--------- Stack
```
То есть хип растет слева направо (с меньших адресов).  
А стек растет справа налево (с больших адресов).
## Protected area
Между ними есть `protected area` - участок памяти, которым нельзя оперировать. Если стек дорастет до этой части  - программа крашится с ошибкой **stack overflow**.
## Stack and heap
Стек и куча - это одна память, но работа с ними происходит по-разному
- Куча: медленнее (аллокации), данные разбросаны, чистится силами [5. GC](5.%20GC.md), нужно синхронизировать доступ. Хранит долгоживущие данные.
- Стек: быстрее(cache-friendly), данные рядом, чистится весь разом. Хранит локальные переменные.
## Почему стек быстрее?
Потому что для аллокации достаточно сдвинуть STACK POINTER (SP), а для деаллокации - подвинуть в обратную сторону. Аллокация идет последовательно - это cache-friendly. В куче же намного больше операций и необходимость дефрагментации памяти.
# Растет вниз (назад)
```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	var (
		x, y int = 1, 2 //on stack
	)

	p1 := unsafe.Pointer(&x)
	p2 := unsafe.Add(p1, -8) // add 8bytes to ptr

	fmt.Println("x = ", *(*int)(p1)) // 1
	fmt.Println("y = ", *(*int)(p2)) // random numbers

	_ = y
}
```

На стек (main) горутины кладется два `int` числа - 1 и 2. Размер каждой переменной - 8 байт. Логично предположить, что если к указателю первой перменной прибавить 8 байт, то этот указатель должен будет указывать на вторую перменную. Но это не так:

Дело в том, что стек горутины **растет вниз**. Адреса идут в обратном порядке. 
```go
x = 0x140000100c8
y = 0x140000100c0
```

Это значит, что адреса стека идут в обратную сторону. Чтобы исправить программу, нам нужно **ВЫЧИТАТЬ** из адреса:
```go
p2 := unsafe.Add(p1, -8) // <--- stack growing down, so decrease address
```

# Непрерывный стек
В Go 1.3 внедрили непрерывный стек, на замену сегментированному стеку:
```
Действующий механизм разделения стека имеет проблему «горячего разделения» — если стек почти заполнен, вызов результирует в выделении нового фрагмента стека. Когда этот вызов возвращается, новый фрагмент стека высвобождается. Если один и тот же вызов происходит неоднократно в коротком цикле, накладные расходы на аллокацию/высвобождение будут ощутимыми.
```
Сегментированный стек приводил к множеству аллокаций если функция вызывается в цикле. Цикличное создание-освобождение сегмента = хотспот.
## Начальный размер стека
У каждой горутины свой стек. 
- Начальный размер - 2КБ.
```go
stackMin = 2048
```
## Максимальный размер стека
- Максимальный размер стека:
	- 1 ГБ для 64-битной ОС
	- 250 МБ для 32-битной ОС
```go
if goarch.PtrSize == 8 {  
	maxstacksize = 1000000000
} 
else {  
	maxstacksize = 250000000
}
```
[Как изменяется размера стека горутины?](https://habr.com/ru/companies/otus/articles/586108/)
Если переменная не помещается на стек - runtime создает новый стек, и переносит все фреймы туда.
## Формализация
**SP** указывает на вершину стека или адрес самого последнего добавленного элемента.
**BP** статичен, указывает на начало фрейма функции или адрес, с которого вносятся значения.
**IP (instruction pointer)** указывает на команду, которая будет выполнена следующей
```                  
stack pointer (SP)                            package main
  V                                       
  +-------+-------+--------+                  func foo() {
  | bar() | foo() | main() |                      bar()
  +-------+-------+--------+                  }
   /                                          func bar() {
  |                                               b := 20
  |                                               a := 30
  |                                           }
  V							                  func main() {
SP               base pointer (BP)                foo()
V                     V                       }   
+----------+----------+-------+--------+
| local    |  local   | prev  | return |
|  a=30    |  b=20    | frame |  addr  |
|  0x06    |  0x08    | 0x0a  | 0x0e   |
+----------+----------+-------+--------+            
```
Инструкции:
- push - занести на стек
- pop - взять со стека
- jmp - перенести IP на нужный адресс
- call - перед jmp, заносит в стек return addr (адрес инструкции следующий за call)
- ret - вытаскивает из стека адрес возврата, переходит по нему
## Возврат из функции
1. mov SP BP (переносим SP на BP)
```
                      BP
				      SP
                      V                        
+~~~~~~~~~~+~~~~~~~~~~+-------+--------+
| local    |  local   | prev  | return |
|  a=30    |  b=20    | frame |  addr  |
|  0x06    |  0x08    | 0x0a  | 0x0e   |
+~~~~~~~~~~+~~~~~~~~~~+-------+--------+            
```
2. pop BP (BP будет указывать не предыдущую функцию, из которой вызвали)
```
						      SP             BP
                              V              V          
+~~~~~~~~~~+~~~~~~~~~~+~~~~~~~+--------+-----+-------+
| local    |  local   | prev  | return |     | prev  |
|  a=30    |  b=20    | frame |  addr  | ... | frame |
|  0x06    |  0x08    | 0x0a  | 0x0e   |     | 0x16  |
+~~~~~~~~~~+~~~~~~~~~~+~~~~~~~+--------+-----+-------+            
```
3. ret

# Как рантайм понимает, что нужно увеличить стек
В ассмемлере видно вызов функции:
```asm
CALL runtime.morestack_noctx(SB)
```
В нем же есть вызов [планировщика](<GMP%20model.md>) и проверка стоит ли горутине передать управление другим.
